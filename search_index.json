[
["index.html", "Genetic Interaction Network Interpretation (GINI): A Tidy Data Science Perspective Section 1 Overview", " Genetic Interaction Network Interpretation (GINI): A Tidy Data Science Perspective Lulu Jiang (lulu.jiang@dpag.ox.ac.uk), Hai Fang (23versify@gmail.com) 2020-02-27 Section 1 Overview We describe three showcases analysing human genetic interactions and/or gene expression data in human tissues. All done exclusively using R one-liner, defined as a sequential pipeline of elementary functions chained together achieving a complex task. We will guide the users through step-by-step instructions on (case 1) how to identify, visualize and interpret network modules of genetic interactions; (case 2) how to identify and interpret tissue-specific genetic interactions; and (case 3) how to carry out genetic interaction-based tissue clustering and differential interaction analysis. All three showcases are producible on its own right, achieved in relatively short runtime (~20 min for case 1, ~15 min for case 2, and ~25 min for case 3). We encourage the users to run through demos first before analysing their own datasets. "],
["materials.html", "Section 2 Materials ", " Section 2 Materials "],
["r-and-packages.html", "2.1 R and packages", " 2.1 R and packages At the time of writing, the most recent version of R is 3.6.2 (Dark and Stormy Night). The instructions of how to install R in different platforms (Linux, OS X and Windows) can be found at https://www.r-project.org where precompiled binaries are provided for download. For Linux users who do not have a sudo privilege, R could be installed from the source code at the home directory (that is, $HOME): wget https://cran.wu.ac.at/src/base/R-3/R-3.6.2.tar.gz tar xvfz R-3.6.2.tar.gz cd R-3.6.2 ./configure --prefix=$HOME/R-3.6.2 make make check make install $HOME/R-3.6.2/bin/R # start R We highly recommend using a dedicated package BiocManager to install and update any packages that have been deposited into Bioconductor and CRAN, two repositories that are exclusive to each other so that a package cannot be deposited into both. BiocManager should be installed first in a conventional way (i.e. using the function install.packages), and then can be used to install other packages in a single step. Once an additional package remotes also installed, BiocManager can be also used to install packages hosted at GitHub, usually as a development repository prior to submission into Bioconductor or CRAN. # first, install the package BiocManager install.packages(&quot;BiocManager&quot;) # then install packages from Bioconductor and CRAN BiocManager::install(c(&quot;biobroom&quot;,&quot;dnet&quot;,&quot;ggrepel&quot;,&quot;gridExtra&quot;,&quot;limma&quot;,&quot;patchwork&quot;,&quot;remotes&quot;,&quot;tidyverse&quot;,&quot;XGR&quot;), dependencies=T) # can also install packages from GitHub BiocManager::install(&quot;centerforopenscience/osfr&quot;) "],
["genetic-interactions.html", "2.2 Genetic interactions", " 2.2 Genetic interactions We extracted human genetic interactions from BioGRID (version 3.5.179) involving 3102 genes (mapped to NCBI GeneID; the same hereinafter) and their 7856 interactions. This dataset was preprocessed into an igraph object (using the igraph package), saved as an RData-formatted file ig.BioGRID_genetic.RData, deposited at https://osf.io/gskpn). ig.BioGRID_genetic ## IGRAPH 0a7230a UN-- 3102 7856 -- ## + attr: name (v/c), geneid (v/n), symbol (v/c), description (v/c), ## | nPMID (e/n) ## + edges from 0a7230a (vertex names): ## [1] A1BG --REV3L A2M --KRAS AAGAB --TP53 AAMP --KRAS ## [5] AANAT --P2RY6 AANAT --SPHK1 AANAT --SSTR5 AANAT --TOP1 ## [9] AARS2 --LEO1 AARS2 --MRPS16 AARS2 --MRPS5 AARS2 --PSMB6 ## [13] AATF --DONSON AATF --GFI1B AATF --MCM3AP ABCB5 --CSK ## [17] ABCB5 --KRAS ABCB7 --AURKA ABCB7 --HSCB ABCB7 --LONP1 ## [21] ABCB7 --MBTPS2 ABCB7 --MED23 ABCB7 --NUBP1 ABCB7 --PITRM1 ## [25] ABCB7 --TAF2 ABCE1 --KRAS ABCG2 --CSK ABCG5 --FLT3 ## + ... omitted several edges "],
["gene-expression.html", "2.3 Gene expression", " 2.3 Gene expression We obtained human tissue RNA-seq datasets (gene-centric expression level quantified as transcripts per million [TPM]) in the GTEx study (version 8). This study recruited ~1000 postmortem donors from which 49 tissues (each tissue with at least 70 donors/samples) were profiled using bulk RNA-seq. To aid in selecting tissue-specific expressed genes and their expression distribution within a tissue, we precalculated descriptive summary for each gene per tissue: ymin (the minimum TPM amongst the same tissue samples), lower (25% quantile), middle (i.e. median), upper (75% quantile) and ymax (the maximum TPM). This per-tissue gene summary data was represented as a tibble object (using the tibble package) and saved as an RData file GTEx_V8_TPM_boxplot.RData. Doing so this dataset, though much reduced in size, is still informative for further extraction of genes expressed in a tissue (filtering by ymin &gt;= 1) and for boxplot visualisation of expression distribution. GTEx_V8_TPM_boxplot ## # A tibble: 1,709,316 x 9 ## ENSG Symbol SMTSD SMTS ymin lower middle upper ymax ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ENSG00000… DDX11L1 Adipose - Subc… Adipose… 0 0 0 0 0.166 ## 2 ENSG00000… DDX11L1 Muscle - Skele… Muscle 0 0 0 0.0150 0.116 ## 3 ENSG00000… DDX11L1 Artery - Tibial Blood V… 0 0 0 0 0.130 ## 4 ENSG00000… DDX11L1 Artery - Coron… Blood V… 0 0 0 0 0.0710 ## 5 ENSG00000… DDX11L1 Heart - Atrial… Heart 0 0 0 0.0143 0.138 ## 6 ENSG00000… DDX11L1 Adipose - Visc… Adipose… 0 0 0 0 0.127 ## 7 ENSG00000… DDX11L1 Uterus Uterus 0 0 0 0.0244 0.148 ## 8 ENSG00000… DDX11L1 Vagina Vagina 0 0 0 0.0202 0.118 ## 9 ENSG00000… DDX11L1 Breast - Mamma… Breast 0 0 0 0.00493 0.0744 ## 10 ENSG00000… DDX11L1 Skin - Not Sun… Skin 0 0 0 0 0.114 ## # … with 1,709,306 more rows "],
["methods.html", "Section 3 Methods ", " Section 3 Methods "],
["case-1.html", "3.1 Case 1", " 3.1 Case 1 We provide the step-by-step instructions on how to identify modular/community structure (Step 2), the essential to subsequently interpret the genetic interaction network, both visually intuitive and scientifically sound. Steps 3-6 detail how to determine 2D coordinates of the network respecting modular structure, and how to add the hull and labelling for each of the modules, while Steps 7-12 show how to perform pathway analysis of modules for knowledge discovery and interpretation. Step 1: Load the packages and import human genetic interaction data (see Materials above). # load packages used in this case library(tidyverse) library(dnet) library(XGR) library(ggrepel) # also load the package &quot;osfr&quot; aided in importing data from https://osf.io/gskpn library(osfr) guid &lt;- &quot;gskpn&quot; # import the genetic interaction network data ig.BioGRID_genetic &lt;- xRDataLoader(&quot;ig.BioGRID_genetic&quot;, guid=guid) # keep the largest interconnected component # return an igraph object called &quot;ig&quot; ig.BioGRID_genetic %&gt;% dNetInduce(nodes_query=V(ig.BioGRID_genetic)$name) -&gt; ig Step 2: Identify modular structure using the multi-level modularity optimisation algorithm. # the object &quot;ig&quot; appended with a node attribute &quot;modules&quot; ig %&gt;% cluster_louvain() %&gt;% membership() -&gt; V(ig)$modules Step 3: Determine 2D coordinates for nodes, initialised within a module (using the Kamada-Kawai layout algorithm) and then adjusted considering between-module relations (via the diffusion-limited aggregation algorithm). # the object &quot;ig&quot; appended with two node attributes &quot;xcoord&quot; and &quot;ycoord&quot; # and an edge attribute &quot;color&quot; ig %&gt;% xAddCoords(&quot;modules&quot;) -&gt; ig Step 4: Visualise the network respecting modular structure. # nodes placed by coordinates # nodes colored by modules using the color scheme &quot;ggplot2&quot; # edges colored differently within a module and between modules # colorbar hidden # return a ggplot object &quot;gg&quot; ig %&gt;% xGGnetwork(node.xcoord=&quot;xcoord&quot;, node.ycoord=&quot;ycoord&quot;, node.color=&quot;modules&quot;, colormap=&quot;ggplot2&quot;, node.color.alpha=0.5, node.size.range=0.3, edge.color=&quot;color&quot;, edge.arrow.gap=0) + guides(color=&quot;none&quot;) -&gt; gg # make node colors discrete with colorbar hidden breaks &lt;- seq(1, n_distinct(V(ig)$modules)) gg + scale_colour_gradientn(colors=xColormap(&quot;ggplot2&quot;)(64), breaks=breaks) -&gt; gg Step 5. Compute the hull for nodes per module that is added as a polygon layer. # data for nodes extracted from the object &quot;gg&quot; # data nested by the column &quot;modules&quot; # apply the function &quot;chull&quot; to the nested data per module # results unnested to obtain the coordinates for hull points per module # edges colored differently within a module and between modules # return a tibble &quot;df_hull&quot; gg$data_nodes %&gt;% nest(data=-modules) %&gt;% mutate(res=map(data,~slice(.x, chull(.x$x,.x$y)))) %&gt;% unnest(res) %&gt;% select(modules, x, y) -&gt; df_hull # the object &quot;gg&quot; added with a polygon layer # hull colored using the color scheme &quot;ggplot2&quot; with the colorbar hidden gg + geom_polygon(data=df_hull,aes(x, y, group=modules, fill=modules),alpha=0.1) + scale_fill_gradientn(colors=xColormap(&quot;ggplot2&quot;)(64), breaks=breaks) + guides(fill=&quot;none&quot;) -&gt; gg Step 6. Label modules as a text layer, altogether shown in FIGURE 1.1. # calculate the centre point coordinates for each of hulls/modules # done so by first grouping by modules # then being summarised into the median point of nodes for each of hulls # return a tibble &quot;df_centre&quot; df_hull %&gt;% group_by(modules) %&gt;% summarise(x0=median(x), y0=median(y))-&gt; df_centre # the object &quot;gg&quot; added with a text layer gg + geom_text_repel(data=df_centre, aes(x0, y0, label=modules)) -&gt; gg # shown collectively by simply typing the object &quot;gg&quot; gg FIGURE 1.1: Network visualisation of human genetic interactions respecting the modular structure. Step 7. Summarise the number of genes found in each module. # extract the number of genes per module ig %&gt;% igraph::as_data_frame(&quot;vertices&quot;) %&gt;% count(modules) -&gt; data # modules sorted by gene numbers, converted into a factor type data %&gt;% arrange(desc(n)) %&gt;% mutate(modules=modules %&gt;% as.character() %&gt;% fct_inorder()) -&gt; data # draw the bar plot data %&gt;% ggplot(aes(modules,n)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;steelblue&quot;) + scale_y_log10(limits=c(1,1000)) + coord_flip() + theme_minimal() Step 8. Perform pathway enrichment analysis for genes in each module. # extract genes per module ig %&gt;% igraph::as_data_frame(&quot;vertices&quot;) %&gt;% select(symbol, modules) %&gt;% arrange(modules) -&gt; df # define the test background df %&gt;% pull(symbol) -&gt; background # perform enrichment analysis using KEGG environmental process pathways # Fisher&#39;s exact test used by default # return a tibble &quot;df_nested&quot; with the list-column &quot;eTerm&quot; for enrichment results # each contains an eTerm object if found, NULL otherwise df %&gt;% nest(data=-modules) %&gt;% mutate(eTerm=map(data, ~xEnricherGenes(.x$symbol, background=background, ontology=&quot;KEGGenvironmental&quot;, guid=guid))) -&gt; df_nested # the tibble &quot;df_nested&quot; with rows/modules filtered out if NULL df_nested %&gt;% filter(map_lgl(eTerm, ~!is.null(.x))) -&gt; df_nested # the tibble &quot;df_nested&quot; appended with two list-columns # the list-column &quot;forest&quot; for forest plot and &quot;ladder&quot; for ladder plot # both plots as a ggplot object df_nested %&gt;% mutate(forest=map(eTerm, ~xEnrichForest(.x))) %&gt;% mutate(ladder=map(eTerm, ~xEnrichLadder(.x))) -&gt; df_nested # print the content of the tibble &quot;df_nested&quot; df_nested Step 9. Explore enrichment results for a module. # print the content of the eTerm object for module 3 # note: the 2nd row of the tibble &quot;df_nested&quot; df_nested$eTerm[[2]] # visualise as a forest plot for module 3 df_nested$forest[[2]] # visualise as a dot plot for module 3 df_nested$ladder[[2]] Step 10. Prepare the output for all modules. # the tibble &quot;df_nested&quot; appended with the list-column &quot;output&quot; # each entry in this list-column is a conventional data frame df_nested %&gt;% mutate(output=map(eTerm, ~xEnrichViewer(.x, &quot;all&quot;))) -&gt; df_nested # print the content of the updated tibble &quot;df_nested&quot; df_nested # the tibble &quot;df_nested&quot; unnested into a tibble &quot;df_output&quot; df_nested %&gt;% select(modules, output) %&gt;% unnest(output) -&gt; df_output # print the content of the tibble &quot;df_nested&quot; df_output Step 11. Output enrichment results into a file output.txt. # write into a text file &quot;output.txt&quot; in the R working directory df_output %&gt;% write_delim(&quot;output.txt&quot;, delim=&quot;\\t&quot;) Step 12. Visualise and compare enrichment results between modules. # rename the column &quot;modules&quot; into &quot;group&quot; in the tibble &quot;df_output&quot; df_output %&gt;% rename(group=modules) %&gt;% as.data.frame() -&gt; df_output # forest plot of up to top 5 pathways enriched (FDR&lt;0.05 and CI&gt;1) per module # return a ggplot object &quot;gg_forest&quot; df_output %&gt;% xEnrichForest(top_num=5, CI.one=F, drop=T, zlim=c(0,20)) -&gt; gg_forest gg_forest # chord plot of pathways (the left-half) enriched in modules (right-half) # up to top 5 pathways (FDR&lt;0.05) per module shown # note: the gap/angle between two halves controlled by the argument &quot;big.gap&quot; df_output %&gt;% xEnrichChord(top_num=5, legend=F, text.size=0.4, big.gap=90) "],
["case-2.html", "3.2 Case 2", " 3.2 Case 2 We illustrate how to perform integrative analysis combining genetic interactions with gene expression data; such strategy is computationally promising given the current technological limits in experimentally generating tissue-specific interactions on a genome scale, particularly for humans. One way doing so is to trim the generic genetic interactions to node genes expressed in a specific tissue. Such trimming allows identification of a genetic interaction network in the whole blood (Step 2), from which a subnetwork with a desired number of interconnected genes is further identified that tend to be highly expressed (Step 3). We also demonstrate how to highlight the subnetwork within the parent network (Step 4). For the interpretation of the subnetwork identified, we illustrate how to perform phenotype enrichment analysis using mammalian phenotype ontology, a tree-like structure containing well-defined terms that are used to annotate mouse knock-out phenotypes (Step 6). Step 1: Load the packages and import human genetic interaction data as well as gene expression data (see Materials). # load packages used in this case library(tidyverse) library(XGR) library(ggrepel) # also load the package &quot;osfr&quot; aided in importing data from https://osf.io/gskpn library(osfr) guid &lt;- &quot;gskpn&quot; # import genetic interaction data # converted into two tibbles &quot;vertices&quot; and &quot;edges&quot; ig.BioGRID_genetic &lt;- xRDataLoader(&quot;ig.BioGRID_genetic&quot;, guid=guid) ig.BioGRID_genetic %&gt;% igraph::as_data_frame(&quot;vertices&quot;) %&gt;% as_tibble() -&gt; vertices ig.BioGRID_genetic %&gt;% igraph::as_data_frame(&quot;edges&quot;) %&gt;% as_tibble() -&gt; edges # import gene expression data GTEx_V8_TPM_boxplot &lt;- xRDataLoader(&quot;GTEx_V8_TPM_boxplot&quot;, guid=guid) Step 2. Identify a genetic interaction network in the whole blood. # extract genes expressed in the whole blood (TPM&gt;=1 in all samples analysed) # also extract median TPM among all blood samples # stored in a tibble &quot;df_blood&quot; GTEx_V8_TPM_boxplot %&gt;% filter(SMTSD==&quot;Whole Blood&quot;, ymin&gt;=1) %&gt;% select(Symbol,middle) -&gt; df_blood # trim the genetic interactions to node genes expressed # return two data frames &quot;nodes&quot; and &quot;links&quot; # return an igraph object &quot;ig_blood&quot; edges %&gt;% semi_join(df_blood, by=c(&quot;from&quot;=&quot;Symbol&quot;)) %&gt;% semi_join(df_blood, by=c(&quot;to&quot;=&quot;Symbol&quot;)) %&gt;% as.data.frame() -&gt; links vertices %&gt;% inner_join(df_blood, by=c(&quot;name&quot;=&quot;Symbol&quot;)) %&gt;% rename(TPM=middle) %&gt;% as.data.frame() -&gt; vertices ig_blood &lt;- igraph::graph_from_data_frame(d=links, directed=F, vertices=vertices) # calculate coordinates using the Fruchterman-Reingold layout algorithm # the object &quot;ig_blood&quot; appended with two node attributes &quot;xcoord&quot; and &quot;ycoord&quot; ig_blood %&gt;% xLayout(&quot;gplot.layout.fruchtermanreingold&quot;) -&gt; ig_blood # calculate node degree (the number of neighbors) # the object &quot;ig_blood&quot; appended with a node attribute &quot;degree&quot; igraph::degree(ig_blood) -&gt; V(ig_blood)$degree # visualise the network # nodes placed by coordinates # nodes sized by degree # sizebar hidden # return a ggplot object &quot;gg_blood&quot; ig_blood %&gt;% xGGnetwork(node.xcoord=&quot;xcoord&quot;, node.ycoord=&quot;ycoord&quot;, node.size=&quot;degree&quot;, node.size.range=c(0.5,2.5), edge.color=&quot;lightblue1&quot;, edge.arrow.gap=0) + guides(size=&quot;none&quot;) -&gt; gg_blood gg_blood Step 3: Further identify a subnetwork with highly expressed genes. # weight nodes by expression (TPM), the higher the more weight # transform the weight into a p-value-like quantity # thus, a node with the higher expression receives a lower p-value vertices %&gt;% mutate(x=log10(TPM), x=100*(x-min(x))/(max(x)-min(x)), pval=10^(-x)) %&gt;% select(symbol,pval) %&gt;% as.data.frame -&gt; data # identify a subnetowrk with a desired number (~30) of interconnected genes # return an igraph object &quot;ig_subg&quot; data %&gt;% xSubneterGenes(network.customised=ig_blood, subnet.size=30) -&gt; ig_subg # the object &quot;ig_subg&quot; appended with a node attribute &quot;TPM&quot; ind &lt;- match(V(ig_subg)$name, vertices$symbol) V(ig_subg)$TPM &lt;- log10(vertices$TPM[ind]) # the object &quot;ig_subg&quot; appended with two node attributes &quot;xcoord&quot; and &quot;ycoord&quot; # based on node coordinates in the object &#39;ig_blood&#39; ind &lt;- match(V(ig_subg)$name, V(ig_blood)$name) V(ig_subg)$xcoord &lt;- V(ig_blood)$xcoord[ind] V(ig_subg)$ycoord &lt;- V(ig_blood)$ycoord[ind] # visualise the subnetwork # nodes labelled by gene names # nodes placed by coordinates # nodes colored by TPM # return a ggplot object &quot;gg_subg&quot; ig_subg %&gt;% xGGnetwork(node.label=&quot;name&quot;, node.label.size=2, node.label.color=&quot;black&quot;, node.label.force=0.05, node.xcoord=&quot;xcoord&quot;, node.ycoord=&quot;ycoord&quot;, node.color=&quot;TPM&quot;, node.color.title=expression(log[10](&quot;median TPM&quot;)), colormap=&quot;brewer.Greens&quot;, zlim=c(0,4), edge.color=&quot;lightblue&quot;, edge.arrow.gap=0) -&gt; gg_subg gg_subg Step 4. Highlight the subnetwork within the parent network. # the &quot;ig_blood&quot; (the parent network) marked by the &quot;ig_subg&quot; (the subnetwork) # return an igraph object &quot;ig_blood2&quot;, the same as &quot;ig_blood&quot; # but appended with a node attribute (&quot;mark&quot;) and edge attribute (&quot;mark&quot;) ig_blood2 &lt;- xMarkNet(ig_blood, ig_subg) # the object &quot;ig_blood2&quot; appended with two node attributes &quot;xcoord&quot; and &quot;ycoord&quot; # coordinates calculated using the Fruchterman-Reingold layout algorithm ig_blood2 %&gt;% xLayout(&quot;gplot.layout.fruchtermanreingold&quot;) -&gt; ig_blood2 # the object &quot;ig_blood2&quot; appended with two edge attributes # &quot;color&quot; for edge coloring and &quot;color.alpha&quot; for edge color transparency E(ig_blood2)$color &lt;- ifelse(E(ig_blood2)$mark==0, &quot;lightblue1&quot;, &quot;darkgreen&quot;) E(ig_blood2)$color.alpha &lt;- ifelse(E(ig_blood2)$mark==0, 0.3, 0.9) # visualise the network highlighted by the subnetwork # nodes placed by coordinates # nodes sized by degree # nodes colored differently, thus, being highlighted # edges colored differently, thus, being highlighted # return a ggplot object &quot;gg_blood2&quot; ig_blood2 %&gt;% xGGnetwork(node.xcoord=&quot;xcoord&quot;, node.ycoord=&quot;ycoord&quot;, , node.size=&quot;degree&quot;, node.size.range=c(0.5,2.5), node.color=&quot;mark&quot;, colormap=&quot;orange-darkgreen&quot;, node.color.alpha=0.7, edge.color=&quot;color&quot;, edge.color.alpha=&quot;color.alpha&quot;, edge.arrow.gap=0) + guides(size=&quot;none&quot;) + guides(color=&quot;none&quot;) -&gt; gg_blood2 gg_blood2 Step 5. Display expression levels for genes in the subnetwork. # extract whole blood expression data for genes in the subnetwork GTEx_V8_TPM_boxplot %&gt;% filter(SMTSD %in% c(&quot;Whole Blood&quot;), Symbol %in% V(ig_subg)$name) -&gt; data # genes ordered by median expression level, converted into a factor data %&gt;% arrange(middle) %&gt;% mutate(Symbol=fct_inorder(Symbol)) -&gt; data # draw the boxplot, showing the distribution among the blood samples data %&gt;% ggplot(aes(x=Symbol)) + geom_boxplot(stat=&quot;identity&quot;, aes(ymin=ymin,lower=lower,middle=middle,upper=upper,ymax=ymax), fill=&quot;green3&quot;) + ylab(&quot;TPM&quot;) + xlab(&quot;&quot;) + scale_y_log10() + coord_flip() + theme_minimal() Step 6. Perform phenotype enrichment analysis for genes in the subnetwork. # define the test background (all genes expressed in the whole blood) GTEx_V8_TPM_boxplot %&gt;% filter(SMTSD==&quot;Whole Blood&quot;, ymin&gt;=1) %&gt;% pull(Symbol) -&gt; background # perform enrichment analysis using mammalian phenotype ontology # return an eTerm object &quot;eTerm&quot; V(ig_subg)$name %&gt;% xEnricherGenes(background=background, ontology=&quot;MP&quot;, guid=guid) -&gt; eTerm # circular visualisation of enriched phenotypes within the ontology eTerm %&gt;% xEnrichGGraph(fixed=F, node.label.direction=&quot;leftright&quot;, slim=c(1,3)) "],
["case-3.html", "3.3 Case 3", " 3.3 Case 3 In this case, we introduce a more advanced analysis workflow, showing how to identify tissue clusters (Steps 2 and 7) and differential interactions (Steps 8-10) based on the integration of genetic interactions with gene expression. Step 1: Load the packages and import human genetic interaction data as well as human tissue gene expression data (see Materials above). # load the packages used in this case library(tidyverse) library(XGR) library(ggrepel) library(magrittr) library(broom) library(limma) library(biobroom) library(patchwork) library(gridExtra) # also load the package &quot;osfr&quot; aided in importing data from https://osf.io/gskpn library(osfr) guid &lt;- &quot;gskpn&quot; # import genetic interaction data # converted into two tibbles &quot;vertices&quot; and &quot;edges&quot; ig.BioGRID_genetic &lt;- xRDataLoader(&quot;ig.BioGRID_genetic&quot;, guid=guid) ig.BioGRID_genetic %&gt;% igraph::as_data_frame(&quot;vertices&quot;) %&gt;% as_tibble() -&gt; vertices ig.BioGRID_genetic %&gt;% igraph::as_data_frame(&quot;edges&quot;) %&gt;% as_tibble() -&gt; edges # import gene expression data GTEx_V8_TPM_boxplot &lt;- xRDataLoader(&quot;GTEx_V8_TPM_boxplot&quot;, guid=guid) Step 2. Estimate tissue-specific interaction weights. # nested by tissues # calculate weight for each interaction and for each tissue # return a tibble &quot;df_nested&quot; with a list-column &quot;interactions&quot; GTEx_V8_TPM_boxplot %&gt;% nest(data=-SMTSD) %&gt;% mutate(interactions=map(data, function(x){ x %&gt;% select(Symbol,middle) -&gt; x edges %&gt;% inner_join(x, by=c(&quot;from&quot;=&quot;Symbol&quot;)) %&gt;% rename(from_TPM=middle) %&gt;% inner_join(x, by=c(&quot;to&quot;=&quot;Symbol&quot;)) %&gt;% rename(to_TPM=middle) %&gt;% mutate(weight=sqrt(log10(from_TPM+1)*log10(1+to_TPM))) })) -&gt; df_nested Step 3. Extract tissue-specific interactions. # unnested by interactions # add interaction name &quot;name&quot; # return a tibble &quot;df_interactions&quot; df_nested %&gt;% select(SMTSD, interactions) %&gt;% unnest(interactions) %&gt;% mutate(name=str_c(from,&quot;&lt;-&gt;&quot;,to)) -&gt; df_interactions Step 4. Prepare a tissue-interaction matrix. # pivot data from long to wide # return a data frame &quot;mat&quot; # also used for differential interaction analysis at Step 8 mat &lt;- df_interactions %&gt;% select(SMTSD, name, weight) %&gt;% pivot_wider(names_from=SMTSD, values_from=weight) %&gt;% column_to_rownames(&quot;name&quot;) Step 5. Conduct the multidimensional scaling on tissues. # based on the pairwise distance between tissues, projected onto 2D space t(mat) %&gt;% dist() %&gt;% cmdscale(2, eig=T) -&gt; res # extract tissue coordinates on 2D space # return a tibble &quot;coord_tissues&quot; with 3 columns # &quot;SMTSD&quot; for tissues, &quot;x1&quot; and &quot;x2&quot; for 2D coordinates res$points %&gt;% set_colnames(c(&quot;x1&quot;,&quot;x2&quot;)) %&gt;% as_tibble(rownames=&quot;SMTSD&quot;) -&gt; coord_tissues Step 6. Optimise the number of tissue clusters using K-means. # perform K-means clustering using a series of cluster numbers (k) # summarise clustering output # set seed to reproduce results # return a tibble &quot;kclusts&quot; set.seed(825) coord_tissues %&gt;% select(x1,x2) -&gt; data kclusts &lt;- tibble(k=1:8) %&gt;% mutate(res=map(k, ~kmeans(data,.x)), glanced=map(res, glance), augmented=map(res, ~augment(.x,data)) ) # the variance within the clusters decreases as k increases # the bend/elbow point indicates no gain having more clusters kclusts %&gt;% unnest(glanced) %&gt;% ggplot(aes(k, tot.withinss)) + geom_line() # tissues colored by clusters for each value of k # note: the same color only means tissues within the same cluster kclusts %&gt;% unnest(augmented) %&gt;% mutate(k=str_c(&quot;k=&quot;,k)) %&gt;% ggplot(aes(x1,x2)) + geom_point(aes(color=.cluster)) + facet_wrap(~k,ncol=4) + guides(color=&quot;none&quot;) Step 7. Visualise the optimal tissue clusters. # assign tissues to one of 5 clusters (optimal) # return a tibble &quot;assignments&quot; kclusts %&gt;% unnest(augmented) %&gt;% filter(k==5) %&gt;% left_join(coord_tissues, by=c(&quot;x1&quot;,&quot;x2&quot;)) -&gt; assignments # tissues shaped by clusters # label brain-derived tissues: two clusters revealed # cluster 4 (cerebellar tissues) # cluster 5 (the rest brain tissues) assignments %&gt;% filter(str_detect(SMTSD, &quot;Brain&quot;)) -&gt; data ggplot(assignments, aes(x1,x2,shape=.cluster)) + geom_point() + geom_text_repel(data=data, aes(label=SMTSD), size=2) + theme_light() Step 8. Detect differential interactions between cluster 5 and other clusters. # define the design matrix # return a matrix &quot;design&quot; assignments %&gt;% mutate(group=ifelse(.cluster==5, &quot;test&quot;, &quot;other&quot;)) %&gt;% select(SMTSD,group) -&gt; df_group df_group %&gt;% pull(group) %&gt;% factor() %&gt;% levels() -&gt; lvls model.matrix(~0+factor(group),df_group) %&gt;% set_colnames(lvls) -&gt; design # fit linear model fit &lt;- lmFit(mat, design) # construct contrast (cluster 5 tested against other clusters) contrast.matrix &lt;- makeContrasts(contrasts=&quot;test-other&quot;, levels=design) # computer contrast from fitted linear model fit2 &lt;- contrasts.fit(fit, contrast.matrix) # calculate empirical Bayes statistics for differential interactions eb &lt;- eBayes(fit2) # tidy eBayes results, and calculate adjusted p-values # return a tibble &quot;df_results&quot; tidy(eb) %&gt;% nest(data=-term) %&gt;% mutate(adjp=map(data,~p.adjust(.x$p.value,method=&quot;BH&quot;))) %&gt;% unnest(c(data,adjp)) %&gt;% arrange(adjp) -&gt; df_results Step 9. Draw volcano plot showing differential interactions. # coefficient estimate [log2(fold change)] vs adjusted p-values # colored by empirical Bayes t-statistic, using the color scheme &quot;jet.both&quot; # return a ggplot object &quot;gg&quot; df_results %&gt;% ggplot(aes(x=estimate, y=-log10(adjp), color=statistic)) + geom_point() + scale_colour_gradientn(colors=xColormap(&quot;jet.both&quot;)(64)) + theme_minimal() + guides(color=&quot;none&quot;) -&gt; gg # label the top 10 interactions abundant in cluster 5 df_results %&gt;% filter(estimate&gt;0) %&gt;% top_n(10, -adjp) -&gt; data gg + geom_text_repel(data=data, aes(label=gene), color=&quot;black&quot;, size=2) Step 10. Construct and visualise a network of abundant interactions in cluster 5. # extract edges with adjp &lt; 0.01 df_results %&gt;% filter(estimate&gt;0, adjp&lt;0.01) %&gt;% separate(gene,c(&quot;from&quot;,&quot;to&quot;),sep=&quot;&lt;-&gt;&quot;) %&gt;% select(from,to,estimate) %&gt;% as.data.frame -&gt; edges_ab # extract nodes with adjp &lt; 0.01 df_results %&gt;% filter(estimate&gt;0, adjp&lt;0.01) %&gt;% separate_rows(gene, sep=&quot;&lt;-&gt;&quot;) %&gt;% distinct(gene) %&gt;% rename(name=gene) %&gt;% inner_join(vertices, by=&quot;name&quot;) %&gt;% as.data.frame() -&gt; nodes_ab # construct the network # return an igraph object &quot;ig_ab&quot; ig_ab &lt;- igraph::graph_from_data_frame(d=edges_ab, directed=F, vertices=nodes_ab) # the object &quot;ig_ab&quot; appended with two node attributes &quot;xcoord&quot; and &quot;ycoord&quot; # coordinates calculated using the Fruchterman-Reingold layout algorithm ig_ab %&gt;% xLayout(&quot;gplot.layout.fruchtermanreingold&quot;) -&gt; ig_ab # the object &quot;ig_ab&quot; appended with a node attribute &quot;degree&quot; (the node degree) igraph::degree(ig_ab) -&gt; V(ig_ab)$degree # the object &quot;ig_ab&quot; appended with a node attribute &quot;label&quot; # in order to label nodes with 2 or more neighbors ifelse(V(ig_ab)$degree&gt;=2, V(ig_ab)$name, &quot;&quot;) -&gt; V(ig_ab)$label # visualise the network # label nodes with 2 or more neighbors # nodes placed by coordinates on the plane # nodes sized by degree # return a ggplot object &quot;gg_ab&quot; ig_ab %&gt;% xGGnetwork(node.label=&quot;label&quot;, node.label.size=1.5, node.xcoord=&quot;xcoord&quot;, node.ycoord=&quot;ycoord&quot;, node.size=&quot;degree&quot;, node.size.range=c(0.5,4), edge.color=&quot;lightblue&quot;, edge.arrow.gap=0) + guides(size=&quot;none&quot;) -&gt; gg_up gg_up Step 11. Perform pathway enrichment analysis for genes involved in abundant interactions in cluster 5. # define the test background (all interacting genes) df_results %&gt;% separate_rows(gene, sep=&quot;&lt;-&gt;&quot;) %&gt;% distinct(gene) %&gt;% pull(gene) -&gt; background # perform enrichment analysis using KEGG pathways # return an eTerm object &quot;eTerm_kegg&quot; V(ig_ab)$name %&gt;% xEnricherGenes(background=background, ontology=&quot;KEGG&quot;, guid=guid) -&gt; eTerm_kegg # visualise enriched pathways faceted by category # label up to top 3 per category eTerm_kegg %&gt;% xEnrichViewer(&quot;all&quot;, detail=T) %&gt;% rename(group=namespace) %&gt;% filter(group %in% c(&quot;Cellular Process&quot;,&quot;Environmental Process&quot;,&quot;Human Diseases&quot;,&quot;Organismal Systems&quot;)) %&gt;% xEnrichDotplot(label.top=3) + facet_wrap(~group, ncol=4) Step 12. Conduct evolutionary analysis for genes involved in abundant interactions in cluster 5. # define the test background (all interacting genes) df_results %&gt;% separate_rows(gene,sep=&quot;&lt;-&gt;&quot;) %&gt;% distinct(gene) %&gt;% pull(gene) -&gt; background # perform evolutionary analysis using phylostratigraphy # based on two-sided Fisher&#39;s exact test # return an eTerm object &quot;eTerm_psg&quot; V(ig_ab)$name %&gt;% xEnricherGenes(background=background, ontology=&quot;PSG&quot;, size.range=c(10,20000), p.tail=&quot;two-tails&quot;, guid=guid) -&gt; eTerm_psg # forest plot for all ancestors analysed # return an ggplot object &quot;gg_psg&quot; xEnrichForest(eTerm_psg, top_num=&quot;auto&quot;, FDR.cutoff=1, sortBy=&quot;none&quot;) -&gt; gg_psg # a table listing genes first created at the ancestors (enriched only) # return a gtable object &quot;gt_psg&quot; eTerm_psg %&gt;% xEnrichViewer(&quot;all&quot;, details=T) %&gt;% as_tibble(rownames=&quot;id&quot;) %&gt;% mutate(id=as.numeric(id)) %&gt;% arrange(id) %&gt;% column_to_rownames(&quot;id&quot;) %&gt;% filter(zscore&gt;0, adjp&lt;0.05) %&gt;% mutate(Ancestor=name, Genes=str_wrap(members_Overlap,width=50)) %&gt;% select(Ancestor,Genes) %&gt;% tableGrob(rows=NULL,theme=ttheme_default(base_size=6)) -&gt; gt_psg # visualise together the forest plot and the table together # using the package &quot;patchwork&quot;, a composer of plots gg_psg + gt_psg + plot_layout(ncol=2, widths=c(1,3)) "],
["session-info.html", "Section 4 Session Info", " Section 4 Session Info Here is the output of sessionInfo() summarising information about R, the OS, and attached/loaded packages: ## R version 3.6.2 (2019-12-12) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS Catalina 10.15.2 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8 ## ## attached base packages: ## [1] grid stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] png_0.1-7 XGR_1.1.8 ggplot2_3.2.1 dnet_1.1.7 ## [5] supraHex_1.24.0 hexbin_1.28.0 igraph_1.2.4.2 ## ## loaded via a namespace (and not attached): ## [1] ggrepel_0.8.1 Rcpp_1.0.3 ape_5.3 ## [4] lattice_0.20-38 utf8_1.1.4 assertthat_0.2.1 ## [7] digest_0.6.23 R6_2.4.1 GenomeInfoDb_1.22.0 ## [10] ggnetwork_0.5.1 stats4_3.6.2 coda_0.19-3 ## [13] evaluate_0.14 highr_0.8 pillar_1.4.3 ## [16] zlibbioc_1.32.0 rlang_0.4.4 lazyeval_0.2.2 ## [19] rstudioapi_0.10 Rgraphviz_2.30.0 S4Vectors_0.24.3 ## [22] RCircos_1.2.1 Matrix_1.2-18 sna_2.5 ## [25] rmarkdown_2.1 readr_1.3.1 stringr_1.4.0 ## [28] RCurl_1.98-1.1 munsell_0.5.0 compiler_3.6.2 ## [31] xfun_0.12 pkgconfig_2.0.3 BiocGenerics_0.32.0 ## [34] htmltools_0.4.0 tidyselect_1.0.0 tibble_2.1.3 ## [37] GenomeInfoDbData_1.2.2 statnet.common_4.3.0 bookdown_0.17 ## [40] IRanges_2.20.2 fansi_0.4.1 crayon_1.3.4 ## [43] dplyr_0.8.3 withr_2.1.2 MASS_7.3-51.5 ## [46] bitops_1.0-6 nlme_3.1-143 gtable_0.3.0 ## [49] lifecycle_0.1.0 magrittr_1.5 scales_1.1.0 ## [52] graph_1.64.0 cli_2.0.1 stringi_1.4.5 ## [55] XVector_0.26.0 vctrs_0.2.2 tools_3.6.2 ## [58] glue_1.3.1 purrr_0.3.3 hms_0.5.3 ## [61] network_1.16.0 parallel_3.6.2 yaml_2.2.0 ## [64] colorspace_1.4-1 GenomicRanges_1.38.0 knitr_1.27 "]
]
